<nav class="toc" style="display: none;">
  <h4>Table of Contents</h4>
  <ul>
  </ul>
</nav>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const content = document.querySelector('.post-content');
    const headers = content.querySelectorAll('h1, h2, h3, h4, h5, h6');
    const toc = document.querySelector('.toc');
    const tocList = toc.querySelector('ul');
    
    if (headers.length > 0) {
      // Filter out TOC header and create header list with hierarchy info
      const headerList = Array.from(headers)
        .filter(header => header.textContent.trim() !== 'Table of Contents')
        .map(header => ({
          id: header.id || header.textContent.toLowerCase().replace(/[^a-z0-9]+/g, '-'),
          text: header.textContent,
          level: parseInt(header.tagName.charAt(1)),
          element: header
        }));

      // Add IDs to headers that don't have them
      headers.forEach((header, index) => {
        if (!header.id && header.textContent.trim() !== 'Table of Contents') {
          header.id = headerList[index]?.id;
        }
      });

      // Function to create nested TOC structure
      function createTocHtml(headers, startIndex = 0, minLevel = Math.min(...headers.map(h => h.level))) {
        let html = '';
        let i = startIndex;
        const currentLevel = headers[i]?.level || minLevel;

        while (i < headers.length) {
          const header = headers[i];
          
          if (header.level === currentLevel) {
            // Start a new list item
            html += '<li>';
            html += `<a href="#${header.id}" class="toc-link toc-link-${header.level}" data-level="${header.level}">${header.text}</a>`;
            
            // Check if next header is a subheader
            if (i + 1 < headers.length && headers[i + 1].level > currentLevel) {
              // Create nested list for subheaders
              const subList = createTocHtml(headers, i + 1, currentLevel + 1);
              if (subList.html) {
                html += '<ul>' + subList.html + '</ul>';
                i = subList.nextIndex - 1; // Adjust index to skip processed subheaders
              }
            }
            
            html += '</li>';
          } else if (header.level < currentLevel) {
            // Return if we encounter a header of higher level
            return { html, nextIndex: i };
          } else {
            // Skip headers of lower level (they will be handled in their own recursion)
            i++;
            continue;
          }
          
          i++;
        }
        
        return { html, nextIndex: i };
      }
      
      // Find the minimum header level to use as the starting point
      const minLevel = Math.min(...headerList.map(h => h.level));
      
      // Generate TOC HTML with hierarchy
      const { html: tocHtml } = createTocHtml(headerList, 0, minLevel);
      
      if (!tocHtml) {
        // Fallback to simple list if hierarchy creation fails
        tocList.innerHTML = headerList.map(header => `
          <li>
            <a href="#${header.id}" class="toc-link toc-link-${header.level}" data-level="${header.level}">
              ${header.text}
            </a>
          </li>
        `).join('');
      } else {
        tocList.innerHTML = tocHtml;
      }
      
      toc.style.display = 'block';

      // Handle smooth scrolling
      tocList.querySelectorAll('a').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const targetId = link.getAttribute('href').substring(1);
          const targetElement = document.getElementById(targetId);
          
          if (targetElement) {
            const headerOffset = 80;
            const elementPosition = targetElement.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

            window.scrollTo({
              top: offsetPosition,
              behavior: 'smooth'
            });
          }
        });
      });

      // Handle active section highlighting
      const observerOptions = {
        root: null,
        rootMargin: '0px',
        threshold: 0.1
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Remove active class from all links
            tocList.querySelectorAll('a').forEach(link => {
              link.classList.remove('is-active-link');
            });

            // Add active class to current section link
            const activeLink = tocList.querySelector(`a[href="#${entry.target.id}"]`);
            if (activeLink) {
              activeLink.classList.add('is-active-link');
            }
          }
        });
      }, observerOptions);

      // Observe all headers
      headers.forEach(header => {
        if (header.textContent.trim() !== 'Table of Contents') {
          observer.observe(header);
        }
      });
    }
  });
</script>

<style>
.toc-wrapper {
  max-height: 70vh;
  overflow-y: auto;
}

.toc-show-more {
  display: block;
  width: 100%;
  padding: 0.5rem;
  margin-top: 1rem;
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  color: #0366d6;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.2s ease;
}

.toc-show-more:hover {
  background: #e9ecef;
  border-color: #ced4da;
}

.toc-link {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
}
</style> 